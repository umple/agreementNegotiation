// This model is a metamodel for
// negotiation. It can be used for
// the development of negotiation tools
// or negotiation domain-specific
// languages

// All negotiations have as their
// objective the creation or update of
// an Agreement. This could be
// an international treaty, a
// commercial agreement for purchase
// and sale, a labour-management
// collective agreement, or anything 
// else
class Agreement {
  title;
  
  // Each agreement is
  // between 2 or more parties
  // which are defined below
  * -- 2..* Party;
  
  // Agreements are updated over time
  // so the latest approved version is
  // actually the most important
  1 -- * AgreementVersion;
  
  displayColor orange;
}

// The legal entities involved in
// negotiation are the Parties
// and the Users who are involved
// in negotiation for one of the 
// parties
//
//
class LegalEntity {
  name;
  address;
  emailAddress;

  displayColor yellow;

}

// All negotiations involve at least
// Two parties. These could be
// sovereign states, corporations,
// unions or individuals
class Party {
  isA LegalEntity;
  1--1..* User;

  displayColor yellow;
}

// A party has Users. The reason for
// tracking these is so that we know
// who is making proposals, or signing
// of on parts of the agreement
class User {
  isA LegalEntity;
  
  enum role {ChiefNegotiator, MemberAtTable, Other}
  
  userid;
  
  displayColor yellow;
}

class NegotiationSession {
}


// Clauses are the core elements of
// an agreement
// Each time a clause is changed
// a new ClauseVersion is created.
// The history of a clause can
// be explored by reviewing its
// versions
class Clause {
  // The internalID is used
  // to tie togetner all the versions
  // of a clause so their history
  // can be tracked
  autounique internalID;
  1 -- * ClauseVersion;
  
  displayColor lightcoral;
}

// An AgreementVersion is made up
// of ClauseVersions, and the
// difference between agreement
// versions is determined by the
// differences in the ClauseVersions
//
// A new ClauseVersion is created
// every time the id, title, text or
// members change
class ClauseVersion { 
  // The ID of a clause will normally
  // be a number or a letter, or
  // for subclauses, a string of these
  // often separated by dots.
  // It will be displayed to the user
  // it can be changed such as when
  // re-ordering, insertion of new
  // clauses or reparenting take place
  // A the top level, the version mignt
  // include a string such as 'Article'
  id;
  
  // A clause may or may not have a
  // title to help identify it
  lazy title;
  
  // The text is the essential legal
  // text of the clause
  text; // Markdown format
  
  // A clause may or may not have lower
  // level clauses
  0..1 higherLevelClause -- 0..1 SubclauseSetVersion subclauses;
  
  displayColor lightsalmon;
}

// A subclauseSetVersion records the
// particular subclauses that are
// nested within a particular version
// of a higher level clause
class SubclauseSetVersion {
  
  * -> * ClauseVersion members;

  displayColor lightsalmon;
}


// An AgreementVersion contains
// a set of top level ClauseVersions
//
// It should be considered like an
// edited version of the agreement
// document, and theregfore may be
// informal, private to one party,
// presented at the negotiation table,
// or in some state of approval
//
// Any change to any clause results
// in a new AgreementVersion even
// if it is a temporary edit
class AgreementVersion {
  isA VisibilityControlledItem;
  
  Date versionDate;
  Time versionTime;
  
  // The changeDescription is
  // optional, but could be used to
  // identify information such as
  // that it was presented to a party
  // or is subject to ratification etc.
  changeDescription;
  
  0..1 <@>- * ClauseVersion;
  
  * -- * Proposal acceptedProposals; // The proposals accepted prior to creation of this
  
  displayColor lightsalmon;
}

// A VisibilityControlledItem is
// something that only certain
// entities are allowed to see
// These include AgreementVersions
// that may be incomplete or being
// prepared by one party
class VisibilityControlledItem {
  
  // An item nay or may not be tagged
  // with an author
  0..1 -- 0..1 User author;
  
  // It may be that only one person
  // such as a person creating a draft
  // can currently see a version, or
  // maybe everybody in a party, or
  // maybe all parties, or maybe just
  // the chief negotiator and an
  // assistant
  *  -- 1..* LegalEntity entitiesllowedToSee;
  
  displayColor darkgoldenrod;
}

// A proposal is made by a party

class Proposal {
  isA VisibilityControlledItem;
  
  autounique  proposalSerialNumber;
  1..* -- * DeltaGroup;
  0..1 -- 1 AgreementVersion; // version these should be applied to

  displayColor moccasin;
}

// A Note is information attached
// to a version or proposal
// Since it is visibility controlled
// it can be private to just one
// user, or to a party, or to
// everybody. 
//
// A note is not a legal part of the
// agreement, but may help people
// to record what others thing,
// or why the change is proposed.
// Sometimes old notes can be used
// to help resolve disputes
// about interpretation
class Note {
  isA VisibilityControlledItem;
  
  // A note is about something
  // a note can even be about another
  // note, such as a private
  // observation about some rationale
  * -- 1 VisibilityControlledItem subject;
  
  // Arbitrary text associated with
  // the item
  markdownText;
  
  // By default there is no need
  // to record a note type, so it
  // would be Unknown. But if the note
  // provides evidence or justification
  // it can be tagged as Rationale,
  // and if the other party has reacted
  // in some way, it can be tagged
  // as FeedbackFromOtherParty to
  // allow for better searches
  enum noteType {Unknown, Rationale, FeedbackFromOtherParty, Other}
  
  displayColor goldenrod;
}


// The following describes the possible 
// changes that can be made to
// Clauses

// Deltas can be of three kinds, but 
// each can apply to a set of clauses
// Deltas are designed to be atomic 
// units of change

class Delta {
  autounique  deltaSerialNumber;

  displayColor lightskyblue;
}

// A ModificationDelta contains
// A list of modifications to specific 
// clauses
// These in turn could be textual
// changes or renumberings
class ModificationDelta {
  isA Delta;
  0..1 -- 1..* ClauseModification;
  displayColor lightskyblue;
}


// A delta group is a set of deltas
// that can be linked by 'and' or
// 'excusive or' and can include other 
// groups
//
// Most groups are linked by 'and' 
// meaning a conjunct
//   a conjunct means that all 
//   deltas and subgroups are 
//   being proposed
// 
// But some groups could be
// alternatives with exclusive or
// 'either this or that,
// but not both'.
//
// Others could be 'disjuncts'.
// 'Any of these ... it does
// not have to be all'
//
// A final approved proposal has to 
// be a conjunct, or just a single
// Delta
class DeltaGroup {
  // This enum describes the kind of
  // DeltaGroup
  enum booleanLink {conjunct, alternative, disjunct};
    
  0..1 -- * Delta;
  0..1 -- * DeltaGroup subgroups;
  displayColor cornflowerblue;
}

// Modifications can be of 3 kinds ... each applying to just one clause

class ClauseModification {
  0..1 -- 1 Clause clauseToModify;
  displayColor lightGreen;
}

class ClauseTextDiff {
  isA ClauseModification;
  textChange; // Markdown diff
  displayColor lightGreen;
}


// When applied to a clause this 
// indicates that the clause should
// have a new number following the
// modification
class ClauseRenumbering {
  isA ClauseModification;
  newNumber;
  displayColor lightGreen;
}

// When applied to a clause, a
// ClauseReparenting indicates that
// the clause should be moved from
// being a subclause of its original
// parent clause, to being a subclause
// or the newParentClause
class ClauseReparenting {
  isA ClauseModification;
  0..1 -- 1 Clause newParentClause;
  displayColor lightGreen;
}
//$?[End_of_model]$?