// This model is a metamodel for
// negotiation. It can be used for
// the development of negotiation tools
// or negotiation domain-specific
// languages

// All negotiations have as their
// objective the creation or update of
// an Agreement. This could be
// an international treaty, a
// commercial agreement for purchase
// and sale, a labour-management
// collective agreement, or anything 
// else
class Agreement {
  // Note that the title of the
  // agreement is determined by
  // the AgreementVersion, since it
  // can change
  
  // Each agreement is
  // between 2 or more parties
  // which are defined below
  * -- 2..* Party;
  
  // Agreements are updated over time
  // so the latest approved version is
  // actually the most important
  1 -- * AgreementVersion;
  
  displayColor orange;
}

// The legal entities involved in
// negotiation are the Parties
// and the Users who are involved
// in negotiation for one of the 
// parties
class LegalEntity {
  name;
  address;
  emailAddress;

  displayColor yellow;
}

// All negotiations involve at least
// Two parties. These could be
// sovereign states, corporations,
// unions or individuals
class Party {
  isA LegalEntity;
  1--1..* User;

  displayColor yellow;
}

// A party has Users. The reason for
// tracking these is so that we know
// who is making proposals, or signing
// of on parts of the agreement
class User {
  isA LegalEntity;
  
  enum role {
    ChiefNegotiator,
    MemberAtTable,
    Other
  }
  
  userid;
  
  displayColor yellow;
}

// A VisibilityControlledItem is
// something that only certain
// LegalEntitles are allowed to see
// These include ItemVersions
// that may be incomplete or being
// prepared by one party
class VisibilityControlledItem {
  
  // An item nay or may not be tagged
  // with an author
  0..1 -- 0..1 User author;
  
  // It may be that only one person
  // such as a person creating a draft
  // can currently see a version, or
  // maybe everybody in a party, or
  // maybe all parties, or maybe just
  // the chief negotiator and an
  // assistant
  *  -- 1..* LegalEntity
    allowedToSee;
  
  displayColor darkgoldenrod;
}

// An Item Version contains
// a set of ClauseVersions
// (subclauses)
//
// Its two subclasses represent
// either an edited version of the
// agreement as a whole, or else
// of one of the clauses.
//
// It may be informal, private to
// one party,
// presented at the negotiation table,
// or in some state of approval
//
// Any change to any contained
// clause results
// in a new ItemVersion even
// if it is a temporary edit
class ItemVersion {
  isA VisibilityControlledItem;
  
  Date versionDate;
  Time versionTime;
  
  // Each version is a result of
  // changes to a previous version
  * -- 0..1 ItemVersion basedOn;

  // An AgreementVersion should have a
  // title but a ClauseVersion may
  // or may not have a
  // title to help identify it
  lazy title;
  
  // The changeDescription is
  // optional, but could be used to
  // identify information such as
  // that it was presented to a party
  // or is subject to ratification etc.
  changeDescription;
  
  0..1 -> * ClauseVersion containedClauses;
  
  //* -- * Proposal acceptedProposals; // The proposals accepted prior to creation of this
  
  displayColor lightsalmon;
}

// This is a special case of
// ItemVersion for the top level
// agreements
class AgreementVersion {
  isA ItemVersion;
  
  // An agreement may have a descriptive
  // Version label that is made
  // public
  versionLabel;
  
  displayColor lightsalmon;

}

// An ItemVersion is made up
// of ClauseVersions, and the
// difference between ItemVersions
// versions is determined by the
// differences in the ClauseVersions
//
// A new ClauseVersion is created
// every time the id, title, text or
// subclauses are edited
//
// A ClauseVersion is only part of an
// agreement version if it is a
// subclause of another ClauseVersion
// and/or is a top level clause of an
// AgreementVersion
//
// Moving a ClauseVersion from one
// parent to another means changing
// both parents
class ClauseVersion {
  isA ItemVersion;

  // The ID of a clause will normally
  // be a number or a letter, or
  // for subclauses, a string of these
  // often separated by dots.
  // It will be displayed to the user
  // it can be changed such as when
  // re-ordering, insertion of new
  // clauses or reparenting take place
  // A the top level, the version mignt
  // include a string such as 'Article'
  //
  // The title would appear after the id
  id;
  
  // The text is the essential legal
  // text of the clause
  // It ises Markdown format
  // To allow for italics etc.
  text; // Markdown format
  
  // A clause may or may not have lower
  // level clauses called subclauses.
  // Note that if we want to find the
  // parent we have to navigate down
  // from the top level 
  // AgreementVersion because otherwise
  // every change to a clause would
  // require creating new versions of
  // its subclauses
  0..1 parentClause -> * ClauseVersion subclauses;
  
  displayColor lightsalmon;
}

// Clauses are the core elements of
// an agreement
//
// Each time a clause is changed
// a new ClauseVersion is created.
// The history of a clause can
// be explored by reviewing its
// versions
class Clause {
  // The internalID is used
  // to tie togetner all the versions
  // of a clause so their history
  // can be tracked even if the clause
  // is radically changed over time
  autounique internalID;
  1 -- * ClauseVersion;
  
  displayColor lightcoral;
}



// A Note is information attached
// to a version or proposal
// Since it is visibility controlled
// it can be private to just one
// user, or to a party, or to
// everybody. 
//
// A note is not a legal part of the
// agreement, but may help people
// to record what others thing,
// or why the change is proposed.
// Sometimes old notes can be used
// to help resolve disputes
// about interpretation
class Note {
  isA VisibilityControlledItem;
  
  // A note is about something
  // a note can even be about another
  // note, such as a private
  // observation about some rationale
  * -- 1 VisibilityControlledItem subject;
  
  // Arbitrary text associated with
  // the item
  markdownText;
  
  // By default there is no need
  // to record a note type, so it
  // would be Unknown. But if the note
  // provides evidence or justification
  // it can be tagged as Rationale,
  // and if the other party has reacted
  // in some way, it can be tagged
  // as FeedbackFromOtherParty to
  // allow for better searches
  enum noteType {Unknown, Rationale, FeedbackFromOtherParty, Other}
  
  displayColor goldenrod;
}


// A Proposal is a set of ItemVersions
// that can be linked by 'and', 'or' or
// 'excusive or'
// 
// It represents ideas for changes to
// an agreement
//
// The simplest case could be a change
// to just one clause
//
// But many Proposals have multiple
// elements, which might be linked
// as follows
//
// Most sets of elements are linked
// by 'and' meaning a conjunct
//   a conjunct means that all 
//   changes are requested to be made
//   together
// 
// But some elements could be
// alternatives with exclusive or
// 'either this or that,
// but not both'.
//
// Others could be 'disjuncts'.
// 'Any of these ... it does
// not have to be all'
//
// A final approved proposal has to 
// be a conjunct, or just hava a single
// element
class Proposal {
  isA ItemVersion;
  
  // This enum describes the kind of
  // Proposal
  enum booleanLink {
    conjunct,
    alternative,
    disjunct
  };
    
  // The elements can be
  // ClauseVersions or
  // Proposals (i.e. sub-proposals)
  0..1 -> * ItemVersion elements;
  
  displayColor cornflowerblue;
}
//$?[End_of_model]$?

namespace -;


class Agreement
{
  position 50 30 109 45;
}

class LegalEntity
{
  position 50 130 109 45;
}

class Party
{
  position 50 230 109 45;
}

class User
{
  position 50 330 109 45;
}

class ClauseVersion
{
  position 250 130 109 45;
}

class AgreementVersion
{
  position 250 230 109 45;
}

class VisibilityControlledItem
{
  position 250 330 109 45;
}

class Note
{
  position 450 30 109 45;
}

class ItemVersion
{
  position 250 230 109 45;
}

class Proposal
{
  position 450 30 109 45;
}

class Clause
{
  position 250 330 109 45;
}